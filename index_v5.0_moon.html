<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODM Gear v3.1 - Fixed Pole Vault Mechanics</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }

        #odmStats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }

        .swingIndicator {
            color: #ffaa00;
            font-weight: bold;
        }

        .vaultReady {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="instructions">
            <strong>ODM Gear Controls:</strong><br>
            WASD - Move (3x speed)<br>
            Mouse - Look around<br>
            <span style="color: #ffaa00;">Hold Left Click - Left Hook & Smart Retract</span><br>
            <span style="color: #ffaa00;">Hold Right Click - Right Hook & Smart Retract</span><br>
            <span style="color: #ffaa00;">Release Click - Release Hook</span><br>
            Space - Jump / Gas Boost<br>
            <span style="color: #ffaa00;">A/D while hooked - Swing around (uses gas)</span><br>
            <span style="color: #88ff88;">IMPROVED: Better Pole Vault Detection!</span><br>
            <span style="color: #88ff88;">FIXED: Swing Tension & Ground Shots!</span><br>
            Click to lock mouse cursor
        </div>

        <div id="crosshair"></div>

        <div id="stats">
            Position: <span id="position">0, 0, 0</span><br>
            FPS: <span id="fps">0</span><br>
            Speed: <span id="speed">0</span><br>
            Height: <span id="height">0</span>m<br>
            Surface: <span id="surface">Ground</span>
        </div>

        <div id="odmStats">
            Left Hook: <span id="leftHook">Ready</span><br>
            Right Hook: <span id="rightHook">Ready</span><br>
            Left Cord: <span id="leftCord">--</span>m<br>
            Right Cord: <span id="rightCord">--</span>m<br>
            Gas: <span id="gas">100%</span><br>
            <span id="swingMode" class="swingIndicator"></span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer;
	let moon; // NEW VARIABLE FOR THE MOON
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let raycaster = new THREE.Raycaster();
        let objects = [];
        let buildings = [];
        let collisionObjects = []; // Separate array for collision detection
        let domeNodes = []; // Geodesic dome connection points
        let isOnGround = false;
        let currentSurface = 'Ground';
        let lastBoostTime = 0; // For boost cooldown
    
        // Mouse controls
        let isPointerLocked = false;
        let pitchObject = new THREE.Object3D();
        let yawObject = new THREE.Object3D();
        
        // Mouse button states
        let leftMouseDown = false;
        let rightMouseDown = false;
        
        // Constants
        const GRAVITY = 40;
        const WALK_SPEED = 120;
        const JUMP_FORCE = 30;
        const AIR_JUMP_FORCE = 25;
        const PLAYER_HEIGHT = 1.8;
        const PLAYER_RADIUS = 0.4; // Player collision radius
        const HOOK_PULL_FORCE = 150;
        const SWING_FORCE = 120; // Lateral force for swinging
        const SWING_GAS_COST = 0.5; // Gas cost per frame while swinging
        
        // Air Physics Constants
        const GROUND_FRICTION = 10.0; // Damping when on ground (higher = more friction)
        const AIR_RESISTANCE = 0.6; // Damping when in air (lower = less resistance, more momentum preservation)
        const AIR_CONTROL = 0.4; // Movement control multiplier when airborne (0.0 = no control, 1.0 = full control)
        
        // Hook & Gas Constants
        const HOOK_RANGE = 150; // Maximum hook range - increased for dome
        const GAS_REGEN_RATE = 0.2; // Gas regeneration per frame
        const JUMP_GAS_COST = 2; // Gas cost for ground jump
        const AIR_JUMP_GAS_COST = 10; // Gas cost for air jump
        const HOOK_GAS_COST = 5; // Gas cost per hook shot
        const JUMP_VELOCITY_THRESHOLD = 5; // Minimum upward velocity to escape rooftop collision
        const RETRACT_SPEED_THRESHOLD = 30; // Don't retract if moving faster than this (safety)
        const RETRACT_DELAY = 0.5; // Seconds to hold before auto-retraction starts
        const HOOK_COOLDOWN_DURATION = 1350; // 1.5 second cooldown


        // Gas Boost Constants
        const GAS_BOOST_FORCE = 15; // Upward force from gas boost
        const GAS_BOOST_COST = 8; // Gas cost per boost
        const POLE_VAULT_MULTIPLIER = 2.8; // Extra boost when conditions are perfect
        
        // SUPER GENEROUS POLE VAULT CONDITIONS - Make it easy to trigger!
        const POLE_VAULT_TENSION_THRESHOLD = 0.3; // Very low tension needed
        const POLE_VAULT_SPEED_THRESHOLD = 3; // Very low speed needed
        const SWING_TENSION_THRESHOLD = 0.1; // Your setting - much lower
        const GROUND_SHOT_DISTANCE = 15; // Lower threshold for ground shots
        const HIGH_SPEED_THRESHOLD = 10; // If moving fast, ignore other requirements
        
        // Dynamic cord physics
        const CORD_TIGHTEN_RATE = 40; // How fast cord tightens during swings
        const MIN_CORD_LENGTH = 8; // Minimum cord length
        
        // World Constants
        const WORLD_SIZE = 600; // Increased world size
        const DOME_RADIUS = 250; // Geodesic dome radius
        const DOME_NODE_SIZE = 6; // Size of dome connection nodes
        const DOME_DETAIL = 2; // Geodesic subdivision level (0-3, higher = more nodes)
    
        // ODM Gear variables
	let hooks = {
			left: {
				attached: false,
				position: null,
				line: null,
				length: 0,
				maxLength: 0,
				naturalLength: 0,
				object: null,
				holdTime: 0,
				isGroundShot: false,
				cooldownUntil: 0 // NEW: Cooldown timer
			},
			right: {
				attached: false,
				position: null,
				line: null,
				length: 0,
				maxLength: 0,
				naturalLength: 0,
				object: null,
				holdTime: 0,
				isGroundShot: false,
				cooldownUntil: 0 // NEW: Cooldown timer
			}
		};
        let gas = 100;
        let hookRange = HOOK_RANGE;
        let isSwinging = false;
        let swingDirection = 0; // -1 for left, 1 for right
    
        // Initialize the game
        function init() {
	// Create scene
			scene = new THREE.Scene();
			// Set night-time background and fog
		// Set night-time background and a more aggressive fog for performance
		scene.background = new THREE.Color(0x030014);
		scene.fog = new THREE.Fog(scene.background, 40, 180); // Fog starts at 120 units, fully opaque at 380



    
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT, 0);
    
            // Set up first-person controls structure
            yawObject.add(pitchObject);
            pitchObject.add(camera);
            scene.add(yawObject);
            yawObject.position.set(0, PLAYER_HEIGHT, 5);
    
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
    


			// --- Create Night Lighting & Moon ---
			// Dim, blueish ambient light
			const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
			scene.add(ambientLight);

			// Moonlight (a directional light)
			const moonlight = new THREE.DirectionalLight(0xaaccff, 0.4);
			moonlight.position.set(-150, 240, -150); // Position it with the moon
			moonlight.castShadow = true;
			moonlight.shadow.mapSize.width = 2048;
			moonlight.shadow.mapSize.height = 2048;
			moonlight.shadow.camera.near = 0.5;
			moonlight.shadow.camera.far = 500;
			moonlight.shadow.camera.left = -WORLD_SIZE/2;
			moonlight.shadow.camera.right = WORLD_SIZE/2;
			moonlight.shadow.camera.top = WORLD_SIZE/2;
			moonlight.shadow.camera.bottom = -WORLD_SIZE/2;
			scene.add(moonlight);


       
            // Create ground with grid
            createGround();
    
            // Create buildings for ODM gear
            createBuildings();
            

					createRealisticMoon();
					createStars();

	
            // Create geodesic dome
            createGeodesicDome();
    
            // Set up event listeners
            setupEventListeners();
    
            // Start the game loop
            animate();
        }
    


        function createRealisticMoon() {
            // Create a detailed moon texture procedurally
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const context = canvas.getContext('2d');

            // Create base moon surface with gradient
            const gradient = context.createRadialGradient(512, 400, 0, 512, 400, 700);
            gradient.addColorStop(0, '#f5f5dc'); // Beige center
            gradient.addColorStop(0.6, '#e6e6dc');
            gradient.addColorStop(1, '#d0d0c0'); // Darker edges
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Add maria (dark patches)
            const mariaRegions = [
                {x: 300, y: 200, radius: 120, intensity: 0.3},
                {x: 600, y: 400, radius: 150, intensity: 0.25},
                {x: 200, y: 600, radius: 100, intensity: 0.35},
                {x: 700, y: 200, radius: 80, intensity: 0.3},
                {x: 450, y: 650, radius: 90, intensity: 0.28}
            ];

            mariaRegions.forEach(maria => {
                const mariaGradient = context.createRadialGradient(
                    maria.x, maria.y, 0, 
                    maria.x, maria.y, maria.radius
                );
                const darkColor = `rgba(100, 100, 85, ${maria.intensity})`;
                mariaGradient.addColorStop(0, darkColor);
                mariaGradient.addColorStop(1, 'rgba(100, 100, 85, 0)');
                context.fillStyle = mariaGradient;
                context.fillRect(0, 0, canvas.width, canvas.height);
            });

            // Add detailed craters
            const craters = [
                {x: 400, y: 300, radius: 40, depth: 0.4},
                {x: 650, y: 250, radius: 30, depth: 0.35},
                {x: 250, y: 500, radius: 35, depth: 0.3},
                {x: 750, y: 600, radius: 25, depth: 0.4},
                {x: 500, y: 700, radius: 45, depth: 0.25},
                {x: 150, y: 300, radius: 20, depth: 0.5}
            ];

            craters.forEach(crater => {
                // Crater shadow
                const shadowGradient = context.createRadialGradient(
                    crater.x, crater.y, 0,
                    crater.x, crater.y, crater.radius
                );
                shadowGradient.addColorStop(0, `rgba(80, 80, 70, ${crater.depth})`);
                shadowGradient.addColorStop(0.7, `rgba(120, 120, 100, ${crater.depth * 0.3})`);
                shadowGradient.addColorStop(1, 'rgba(120, 120, 100, 0)');
                context.fillStyle = shadowGradient;
                context.beginPath();
                context.arc(crater.x, crater.y, crater.radius, 0, Math.PI * 2);
                context.fill();

                // Crater rim highlight
                context.strokeStyle = `rgba(255, 255, 240, ${crater.depth * 0.6})`;
                context.lineWidth = 2;
                context.beginPath();
                context.arc(crater.x, crater.y, crater.radius * 0.9, 0, Math.PI * 2);
                context.stroke();
            });

            // Add hundreds of small craters for detail
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 8 + 2;
                const intensity = Math.random() * 0.2 + 0.1;
                
                context.fillStyle = `rgba(80, 80, 70, ${intensity})`;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fill();
            }

            // Add surface texture with noise
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 30;
                data[i] += noise;     // Red
                data[i + 1] += noise; // Green
                data[i + 2] += noise; // Blue
            }
            context.putImageData(imageData, 0, 0);

            const moonTexture = new THREE.CanvasTexture(canvas);
            moonTexture.wrapS = THREE.RepeatWrapping;
            moonTexture.wrapT = THREE.RepeatWrapping;

            // Create normal map for surface detail
            const normalCanvas = document.createElement('canvas');
            normalCanvas.width = 512;
            normalCanvas.height = 512;
            const normalContext = normalCanvas.getContext('2d');
            
            // Generate normal map data
            normalContext.fillStyle = '#8080ff'; // Base normal color
            normalContext.fillRect(0, 0, normalCanvas.width, normalCanvas.height);
            
            // Add bumps and details
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * normalCanvas.width;
                const y = Math.random() * normalCanvas.height;
                const size = Math.random() * 3 + 1;
                const intensity = Math.random() * 50 + 50;
                
                normalContext.fillStyle = `rgb(${intensity}, ${intensity}, ${255 - intensity})`;
                normalContext.beginPath();
                normalContext.arc(x, y, size, 0, Math.PI * 2);
                normalContext.fill();
            }
            
            const normalTexture = new THREE.CanvasTexture(normalCanvas);

            // Create the moon with enhanced material
            const moonGeometry = new THREE.SphereGeometry(35, 64, 64);
            const moonMaterial = new THREE.MeshStandardMaterial({
                map: moonTexture,
                normalMap: normalTexture,
                normalScale: new THREE.Vector2(0.3, 0.3),
                roughness: 0.95,
                metalness: 0.02,
                emissive: new THREE.Color(0x111122),
                emissiveIntensity: 0.05
            });

            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(-150, 320, -150);
            moon.userData = { type: 'moon', name: 'The Moon' };
            scene.add(moon);
            buildings.push(moon); // Make it hook-able

            // Create enhanced moonlight with better shadows
            moonlight = new THREE.DirectionalLight(0xaaccff, 0.8);
            moonlight.position.set(-150, 320, -150);
            moonlight.target.position.set(0, 0, 0);
            moonlight.castShadow = true;
            
            // Enhanced shadow settings
            moonlight.shadow.mapSize.width = 4096;
            moonlight.shadow.mapSize.height = 4096;
            moonlight.shadow.camera.near = 0.5;
            moonlight.shadow.camera.far = 800;
            moonlight.shadow.camera.left = -WORLD_SIZE/2;
            moonlight.shadow.camera.right = WORLD_SIZE/2;
            moonlight.shadow.camera.top = WORLD_SIZE/2;
            moonlight.shadow.camera.bottom = -WORLD_SIZE/2;
            moonlight.shadow.bias = -0.0001;
            
            scene.add(moonlight);
            scene.add(moonlight.target);

            // Add subtle moon glow effect
            const glowGeometry = new THREE.SphereGeometry(40, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xaaccff,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const moonGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            moonGlow.position.copy(moon.position);
            scene.add(moonGlow);
        }

function createStars() {
			const starVertices = [];
			for (let i = 0; i < 15000; i++) {
				const x = THREE.MathUtils.randFloatSpread(WORLD_SIZE * 2);
				const y = THREE.MathUtils.randFloat(50, WORLD_SIZE / 2);
				const z = THREE.MathUtils.randFloatSpread(WORLD_SIZE * 2);
				starVertices.push(x, y, z);
			}

			const starGeometry = new THREE.BufferGeometry();
			starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

			const starMaterial = new THREE.PointsMaterial({
				color: 0xffffff,
				size: 0.75,
				transparent: true,
				opacity: 0.8
			});

			const stars = new THREE.Points(starGeometry, starMaterial);
			scene.add(stars);
		}

        function createGround() {
            // Main ground plane - larger
            const groundGeometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            ground.userData = { type: 'ground' };
            scene.add(ground);
            objects.push(ground);
            collisionObjects.push(ground);
    
            // Grid lines - larger
            const gridHelper = new THREE.GridHelper(WORLD_SIZE, 150, 0x000000, 0x000000);
            gridHelper.position.y = 0.01;
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }
    
        function createBuildings() {
            // Create a dense city with much taller buildings - spread over larger area
            const buildingCount = 40; // More buildings for larger world
            const cityRadius = 200; // Larger radius
            
            for (let i = 0; i < buildingCount; i++) {
                // Distribute buildings in a rough grid with some randomness
                const angle = (i / buildingCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
                const distance = 30 + Math.random() * cityRadius;
                const x = Math.cos(angle) * distance + (Math.random() - 0.5) * 30;
                const z = Math.sin(angle) * distance + (Math.random() - 0.5) * 30;
                
                // Much taller buildings - skyscrapers!
                const height = 40 + Math.random() * 120; // Even taller buildings
                const width = 8 + Math.random() * 12;
                const depth = 8 + Math.random() * 12;
    
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color().setHSL(0.1, 0.2 + Math.random() * 0.3, 0.3 + Math.random() * 0.3)
                });
    
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(x, height / 2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                building.userData = { 
                    type: 'building', 
                    width: width, 
                    height: height, 
                    depth: depth,
                    name: `Building ${i + 1}`
                };
    
                scene.add(building);
                objects.push(building);
                buildings.push(building);
                collisionObjects.push(building); // Add to collision objects
    
                // Add windows
                const windowGeometry = new THREE.PlaneGeometry(1.2, 1.8);
                const windowMaterial = new THREE.MeshBasicMaterial({ 
                    color: Math.random() > 0.3 ? 0xffff88 : 0x444444
                });
    
                for (let side = 0; side < 4; side++) {
                    for (let floor = 3; floor < height - 3; floor += 4) {
                        for (let windowNum = 0; windowNum < 2; windowNum++) {
                            const window = new THREE.Mesh(windowGeometry, windowMaterial.clone());
                            const angle = (side * Math.PI) / 2;
                            const sideDistance = (side % 2 === 0) ? width / 2 + 0.01 : depth / 2 + 0.01;
                            const windowOffset = (windowNum - 0.5) * (side % 2 === 0 ? width : depth) * 0.4;
    
                            window.position.set(
                                x + Math.sin(angle) * sideDistance + Math.cos(angle) * windowOffset,
                                floor,
                                z + Math.cos(angle) * sideDistance - Math.sin(angle) * windowOffset
                            );
                            window.rotation.y = angle;
                            scene.add(window);
                        }
                    }
                }
                
                // Add rooftop details
                if (Math.random() > 0.7) {
                    const antennaGeometry = new THREE.CylinderGeometry(0.1, 0.1, 5 + Math.random() * 10);
                    const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.set(x, height + antenna.geometry.parameters.height / 2, z);
                    scene.add(antenna);
                    buildings.push(antenna);
                }
            }
        }
 

	function createGeodesicDome() {
			// Create geodesic dome structure
			const radius = DOME_RADIUS;
			const detail = DOME_DETAIL; // Level of subdivision for the geodesic

			// Create icosphere geometry for geodesic dome
			const geometry = new THREE.IcosahedronGeometry(radius, detail);

			// --- Node Material ---
			// The base color is still influenced by moonlight, but the emissive property makes it glow cyan.
			const nodeGeometry = new THREE.SphereGeometry(DOME_NODE_SIZE, 8, 6);
			const nodeMaterial = new THREE.MeshLambertMaterial({
				color: 0xeeeeee, // A bright base color
				emissive: new THREE.Color(0x00ffff), // The glow color (cyan)
				emissiveIntensity: 0.7 // How bright the glow is
			});

			// Create connection nodes at vertices
			const vertices = geometry.attributes.position.array;
			for (let i = 0; i < vertices.length; i += 3) {
				const x = vertices[i];
				const y = vertices[i + 1] + 50; // Lift dome above ground
				const z = vertices[i + 2];

				// Only create nodes in upper hemisphere and some lower ones for variety
				if (y > 30 || Math.random() > 0.7) {
					const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
					node.position.set(x, y, z);
					node.userData = { type: 'domeNode' };
					scene.add(node);
					buildings.push(node); // Add to buildings so hooks can attach
					domeNodes.push(node);
				}
			}

			// --- Wireframe Material ---
			// We'll change this to a dark cyan to match the glow
			const wireframeGeometry = new THREE.IcosahedronGeometry(radius, detail);
			const wireframeMaterial = new THREE.MeshBasicMaterial({
				color: 0x008888, // Dark cyan
				wireframe: true,
				transparent: true,
				opacity: 0.2
			});

			const wireframeDome = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
			wireframeDome.position.y = 50; // Lift dome above ground
			scene.add(wireframeDome);

			// --- Strut Material ---
			// Give the struts a very faint matching glow so they aren't totally black
			const strutMaterial = new THREE.MeshLambertMaterial({
				color: 0x555555,
				emissive: new THREE.Color(0x005555), // A very dim glow
				emissiveIntensity: 0.5
			});

			for (let i = 0; i < domeNodes.length; i++) {
				for (let j = i + 1; j < domeNodes.length; j++) {
					const node1 = domeNodes[i];
					const node2 = domeNodes[j];
					const distance = node1.position.distanceTo(node2.position);

					// Only connect nearby nodes to avoid too many struts
					if (distance < 40 && Math.random() > 0.8) {
						const strutGeometry = new THREE.CylinderGeometry(0.3, 0.3, distance);
						const strut = new THREE.Mesh(strutGeometry, strutMaterial);

						// Position strut between nodes
						strut.position.copy(node1.position).add(node2.position).multiplyScalar(0.5);
						strut.lookAt(node2.position);
						strut.rotateX(Math.PI / 2);

						scene.add(strut);
					}
				}
			}
		}
    
        function setupEventListeners() {
            // Mouse button events
            document.addEventListener('mousedown', (event) => {
                if (!isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                } else {
                    event.preventDefault();
                    if (event.button === 0) {
                        leftMouseDown = true;
                        shootHook('left');
                    } else if (event.button === 2) {
                        rightMouseDown = true;
                        shootHook('right');
                    }
                }
            });

            document.addEventListener('mouseup', (event) => {
                if (isPointerLocked) {
                    event.preventDefault();
                    if (event.button === 0) {
                        leftMouseDown = false;
                        if (hooks.left.attached) {
                            releaseHook('left');
                        }
                    } else if (event.button === 2) {
                        rightMouseDown = false;
                        if (hooks.right.attached) {
                            releaseHook('right');
                        }
                    }
                }
            });

            // Prevent context menu
            document.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });
    
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });
    
            // Mouse movement
            document.addEventListener('mousemove', (event) => {
                if (!isPointerLocked) return;
    
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
    
                yawObject.rotation.y -= movementX * 0.002;
                pitchObject.rotation.x -= movementY * 0.002;
    
                // Limit pitch
                pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
            });
    
            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        moveForward = true;
                        break;
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'KeyS':
                        moveBackward = true;
                        break;
                    case 'KeyD':
                        moveRight = true;
                        break;
                    case 'Space':
                        event.preventDefault();
                        jump();
                        break;
                }
            });
    
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        moveForward = false;
                        break;
                    case 'KeyA':
                        moveLeft = false;
                        break;
                    case 'KeyS':
                        moveBackward = false;
                        break;
                    case 'KeyD':
                        moveRight = false;
                        break;
                }
            });
    
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function jump() {
            const currentTime = performance.now();
            
            if (isOnGround) {
                velocity.y = JUMP_FORCE;
                gas -= JUMP_GAS_COST;
                // Clear ground state to allow falling
                isOnGround = false;
                currentSurface = 'Air';
            } else if (gas >= GAS_BOOST_COST && currentTime - lastBoostTime > 200) {
                // Gas boost - fight against gravity
                const hasAttachedHook = hooks.left.attached || hooks.right.attached;
                
                // Check for pole vault conditions - MOVED OUTSIDE isOnGround check!
                let poleVaultBonus = 1.0;
                let vaultReady = false;
                
                if (hasAttachedHook) {
                    // SUPER SIMPLE TEST - If hooked and ANY movement at all
                    const totalSpeed = Math.sqrt(velocity.x**2 + velocity.y**2 + velocity.z**2);
                    
                    if (totalSpeed > 0.1) { // Almost any movement at all
                        poleVaultBonus = POLE_VAULT_MULTIPLIER;
                        vaultReady = true;
                    }
                    
                    // Apply boost with potential pole vault bonus
                    velocity.y += GAS_BOOST_FORCE * poleVaultBonus;
                    gas -= GAS_BOOST_COST;
                    
                    // Visual feedback for successful pole vault
                    if (vaultReady) {
                        currentSurface = 'POLE VAULT! ⚡';
                        setTimeout(() => {
                            if (currentSurface === 'POLE VAULT! ⚡') currentSurface = 'Air';
                        }, 1000);
                    }
                } else {
                    // Regular air boost
                    velocity.y += GAS_BOOST_FORCE * 0.6; // Reduced effectiveness without hooks
                    gas -= GAS_BOOST_COST;
                }
                
                lastBoostTime = currentTime;
            }
        }

function shootHook(side) {
			const currentTime = performance.now();
			
			// --- DEBUG LOGS ---
			console.log(`Trying to shoot ${side} hook. Current time: ${Math.round(currentTime)}`);
			if (hooks[side].cooldownUntil > currentTime) {
				console.error('Action blocked: Hook is on cooldown.'); // Use .error to make it stand out
				return;
			}

			if (hooks[side].attached || gas <= 0) return;
	
			// Cast ray from camera 	
			raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
			const intersects = raycaster.intersectObjects([...buildings, ...domeNodes, ...collisionObjects]);
	
			if (intersects.length > 0) {
				const intersection = intersects[0];
				const distance = intersection.distance;
	
				if (distance <= hookRange) {
					console.log(`%cSuccessfully fired ${side} hook!`, 'color: lightgreen');
					hooks[side].attached = true;
					hooks[side].position = intersection.point.clone();
					hooks[side].length = distance;
					hooks[side].object = intersection.object;
					hooks[side].holdTime = 0; // Reset hold timer
					
					const hookPos = hooks[side].position;
					const playerPos = yawObject.position;
					const heightDifference = playerPos.y - hookPos.y;
					
					hooks[side].isGroundShot = intersection.object.userData.type === 'ground' || heightDifference > GROUND_SHOT_DISTANCE;
					
					if (hooks[side].isGroundShot) {
						hooks[side].naturalLength = Math.max(MIN_CORD_LENGTH, distance * 0.4);
					} else {
						hooks[side].naturalLength = Math.max(MIN_CORD_LENGTH, distance * 0.7);
					}
					
					hooks[side].maxLength = distance;
	
					const lineGeometry = new THREE.BufferGeometry().setFromPoints([
						yawObject.position.clone(),
						hooks[side].position
					]);
					const lineMaterial = new THREE.LineBasicMaterial({ 
						color: side === 'left' ? 0xff4444 : 0x44ff44,
						linewidth: 3
					});
					hooks[side].line = new THREE.Line(lineGeometry, lineMaterial);
					scene.add(hooks[side].line);
	
					gas -= HOOK_GAS_COST;
					updateHookUI();
				}
			}
		}

	function releaseHook(side) {
			if (hooks[side].attached) {
				// Store current velocity before releasing to preserve momentum
				const currentVelocity = velocity.clone();
				
				hooks[side].attached = false;
				hooks[side].position = null;
				hooks[side].length = 0;
				hooks[side].maxLength = 0;
				hooks[side].naturalLength = 0;
				hooks[side].object = null;
				hooks[side].holdTime = 0;
				hooks[side].isGroundShot = false;
				if (hooks[side].line) {
					scene.remove(hooks[side].line);
					hooks[side].line = null;
				}

				// Start the cooldown for this hook
				hooks[side].cooldownUntil = performance.now() + HOOK_COOLDOWN_DURATION;
				
				// --- DEBUG LOG ---
				console.log(`Releasing ${side} hook. Cooldown will end at timestamp: ${Math.round(hooks[side].cooldownUntil)}`);

				// Only add upward boost if no hooks remain and not moving up much
				if (!hooks.left.attached && !hooks.right.attached && currentVelocity.y < JUMP_VELOCITY_THRESHOLD) {
					velocity.y = Math.max(currentVelocity.y + 8, currentVelocity.y);
				}
				
				// Check if still swinging with other hook
				if (!hooks.left.attached && !hooks.right.attached) {
					isSwinging = false;
					swingDirection = 0;
				}
				
				updateHookUI();
			}
		}    

	    function releaseHooks() {
			// Store current velocity before releasing to preserve momentum
			const currentVelocity = velocity.clone();

			['left', 'right'].forEach(side => {
				if (hooks[side].attached) {
					hooks[side].attached = false;
					hooks[side].position = null;
					hooks[side].length = 0;
					hooks[side].maxLength = 0;
					hooks[side].naturalLength = 0;
					hooks[side].object = null;
					hooks[side].holdTime = 0;
					hooks[side].isGroundShot = false;
					if (hooks[side].line) {
						scene.remove(hooks[side].line);
						hooks[side].line = null;
					}
					// Start the cooldown for this hook
					hooks[side].cooldownUntil = performance.now() + HOOK_COOLDOWN_DURATION;
				}
			});

			// Preserve horizontal momentum from swinging
			// Only add upward boost if not already moving up significantly
			if (currentVelocity.y < JUMP_VELOCITY_THRESHOLD) {
				velocity.y = Math.max(currentVelocity.y + 8, currentVelocity.y);
			} else {
				// Keep the existing upward velocity
				velocity.y = currentVelocity.y;
			}

			// Preserve horizontal velocity completely
			velocity.x = currentVelocity.x;
			velocity.z = currentVelocity.z;

			isSwinging = false;
			swingDirection = 0;
			updateHookUI();
		}


function updateHookUI() {
			const getHookStatus = (side) => {
				const currentTime = performance.now();
				
				// Show cooldown status if active
				if (hooks[side].cooldownUntil > currentTime) {
					const cooldownLeft = (hooks[side].cooldownUntil - currentTime) / 1000;
					return `<span style="color: #ff8888;">Cooling (${cooldownLeft.toFixed(1)}s)</span>`;
				}

				if (!hooks[side].attached) return '<span style="color: #aaffaa;">Ready</span>';

				const isHeld = (side === 'left' && leftMouseDown) || (side === 'right' && rightMouseDown);
				if (!isHeld) return 'Attached';
				
				const currentSpeed = Math.sqrt(velocity.x**2 + velocity.y**2 + velocity.z**2);
				const shouldRetract = hooks[side].holdTime > RETRACT_DELAY && 
									  currentSpeed < RETRACT_SPEED_THRESHOLD &&
									  !isSwinging;
				
				if (shouldRetract) return 'Retracting';
				if (isSwinging) return 'Swinging';
				if (currentSpeed >= RETRACT_SPEED_THRESHOLD) return 'High Speed';
				
				// Vault Ready check
				const totalSpeed = Math.sqrt(velocity.x**2 + velocity.y**2 + velocity.z**2);
				if (hooks[side].attached && totalSpeed > 0.1) {
					return '<span class="vaultReady">VAULT READY! ⚡</span>';
				}
				
				const holdTimeLeft = RETRACT_DELAY - hooks[side].holdTime;
				return `Holding (${holdTimeLeft.toFixed(1)}s)`;
			};
			
			document.getElementById('leftHook').innerHTML = getHookStatus('left');
			document.getElementById('rightHook').innerHTML = getHookStatus('right');
			document.getElementById('leftCord').textContent = hooks.left.attached ? hooks.left.length.toFixed(1) : '--';
			document.getElementById('rightCord').textContent = hooks.right.attached ? hooks.right.length.toFixed(1) : '--';
			document.getElementById('gas').textContent = Math.round(gas) + '%';
			document.getElementById('swingMode').textContent = isSwinging ? 
				`Swinging ${swingDirection < 0 ? 'Left' : 'Right'}! Speed: ${Math.sqrt(velocity.x**2 + velocity.y**2 + velocity.z**2).toFixed(1)}` : '';
		}

 
				  function checkCollision(newPosition) {
			const playerBounds = {
				x: newPosition.x,
				y: newPosition.y,
				z: newPosition.z,
				radius: PLAYER_RADIUS,
				height: PLAYER_HEIGHT
			};

			for (let building of collisionObjects) {
				if (building.userData.type === 'ground') {
					if (playerBounds.y - playerBounds.height <= 0 && velocity.y <= 0) {
						return {
							collision: true,
							surface: 'Ground',
							correctedY: playerBounds.height,
							object: building,
							sideCollision: false
						};
					}
				} else if (building.userData.type === 'building') {
					const buildingBounds = {
						x: building.position.x,
						y: building.position.y,
						z: building.position.z,
						width: building.userData.width,
						height: building.userData.height,
						depth: building.userData.depth
					};

					const rooftopY = buildingBounds.y + buildingBounds.height / 2;
					const buildingBottomY = buildingBounds.y - buildingBounds.height / 2;
					const playerBottomY = playerBounds.y - playerBounds.height;
					const playerTopY = playerBounds.y;

					// Basic AABB check first for performance
					const intersectsHorizontally =
						Math.abs(playerBounds.x - buildingBounds.x) < (buildingBounds.width / 2 + playerBounds.radius) &&
						Math.abs(playerBounds.z - buildingBounds.z) < (buildingBounds.depth / 2 + playerBounds.radius);

					if (intersectsHorizontally) {
						// Check for Rooftop landing
						if (playerBottomY <= rooftopY && playerBottomY >= rooftopY - 2.0 && velocity.y <= 0) {
							if (velocity.y <= JUMP_VELOCITY_THRESHOLD) {
								return {
									collision: true,
									surface: building.userData.name || 'Rooftop',
									correctedY: rooftopY + playerBounds.height,
									object: building,
									sideCollision: false
								};
							}
						}

						// Check for side wall collision
						if (playerTopY > buildingBottomY && playerBottomY < rooftopY) {
							const dx = playerBounds.x - buildingBounds.x;
							const dz = playerBounds.z - buildingBounds.z;
							const halfW = buildingBounds.width / 2;
							const halfD = buildingBounds.depth / 2;

							const overlapX = (halfW + playerBounds.radius) - Math.abs(dx);
							const overlapZ = (halfD + playerBounds.radius) - Math.abs(dz);

							const collisionNormal = new THREE.Vector3();
							let correctedPos = newPosition.clone();

							// Determine the shallowest axis of penetration to find the collision normal
							if (overlapX < overlapZ) {
								const sign = Math.sign(dx);
								collisionNormal.set(sign, 0, 0);
								correctedPos.x = buildingBounds.x + sign * (halfW + playerBounds.radius);
							} else {
								const sign = Math.sign(dz);
								collisionNormal.set(0, 0, sign);
								correctedPos.z = buildingBounds.z + sign * (halfD + playerBounds.radius);
							}

							return {
								collision: true,
								surface: 'Wall',
								sideCollision: true,
								correctedX: correctedPos.x,
								correctedZ: correctedPos.z,
								object: building,
								normal: collisionNormal
							};
						}
					}
				}
			}

			return { collision: false };
		}

        function updateMovement(delta) {
            // Store original position
            const originalPosition = yawObject.position.clone();
            
            // Apply gravity
            velocity.y -= GRAVITY * delta;
        
            let hasAttachedHook = hooks.left.attached || hooks.right.attached;
            
            // Check for swing input while hooked
            if (hasAttachedHook && gas > 0) {
                if (moveLeft) {
                    isSwinging = true;
                    swingDirection = -1;
                } else if (moveRight) {
                    isSwinging = true;
                    swingDirection = 1;
                } else {
                    isSwinging = false;
                    swingDirection = 0;
                }
            } else {
                isSwinging = false;
                swingDirection = 0;
            }
        
            if (hasAttachedHook) {
                // ODM gear physics - process each hook
                ['left', 'right'].forEach(side => {
                    if (hooks[side].attached) {
                        const hookPos = hooks[side].position;
                        const playerPos = yawObject.position;
                        
                        // Check if mouse button is still held for this hook
                        const isHeld = (side === 'left' && leftMouseDown) || (side === 'right' && rightMouseDown);
                        
                        if (isHeld) {
                            // Track how long we've been holding
                            hooks[side].holdTime += delta;
                            
                            // Smart retraction: only retract if conditions are safe
                            const currentSpeed = Math.sqrt(velocity.x**2 + velocity.y**2 + velocity.z**2);
                            const shouldRetract = hooks[side].holdTime > RETRACT_DELAY && 
                                                currentSpeed < RETRACT_SPEED_THRESHOLD &&
                                                !isSwinging; // Don't retract while actively swinging
                            
                            if (shouldRetract) {
                                // Tighten cord while held - reduce max length gradually
                                const tightenRate = 20 * delta; // Tightening speed
                                const currentDistance = playerPos.distanceTo(hookPos);
                                
                                // Only tighten if we're not already at minimum distance
                                if (hooks[side].maxLength > Math.max(currentDistance - 5, MIN_CORD_LENGTH)) {
                                    hooks[side].maxLength = Math.max(hooks[side].maxLength - tightenRate, 
                                                                   Math.max(currentDistance - 5, MIN_CORD_LENGTH));
                                }
                            }
                        } else {
                            // Reset hold timer when not holding
                            hooks[side].holdTime = 0;
                        }
                        
                        // NEW: Dynamic cord tightening during swings
                        if (isSwinging || Math.sqrt(velocity.x**2 + velocity.z**2) > 15) {
                            // When swinging or moving fast horizontally, cord naturally tightens
                            const tightenRate = CORD_TIGHTEN_RATE * delta;
                            const targetLength = hooks[side].naturalLength;
                            
                            if (hooks[side].maxLength > targetLength) {
                                hooks[side].maxLength = Math.max(hooks[side].maxLength - tightenRate, targetLength);
                            }
                        }
                    
                        // Update cord length
                        hooks[side].length = playerPos.distanceTo(hookPos);
                    
                        // Calculate direction from player to hook point
                        const toHook = new THREE.Vector3().subVectors(hookPos, playerPos);
                        toHook.normalize();
                    
                        // Calculate the force vector
                        const pullForceVector = toHook.multiplyScalar(HOOK_PULL_FORCE * delta);
                    
                        // Add the force to the velocity
                        velocity.add(pullForceVector);
                        
                        // Apply swing mechanics
                        if (isSwinging && gas > SWING_GAS_COST) {
                            // Calculate perpendicular direction for swinging
                            const playerToHook = new THREE.Vector3().subVectors(hookPos, playerPos);
                            playerToHook.y = 0; // Project onto horizontal plane
                            playerToHook.normalize();
                            
                            // Get perpendicular direction
                            const swingDir = new THREE.Vector3();
                            swingDir.x = -playerToHook.z * swingDirection;
                            swingDir.z = playerToHook.x * swingDirection;
                            swingDir.normalize();
                            
                            // Apply swing force
                            const swingForceVector = swingDir.multiplyScalar(SWING_FORCE * delta);
                            velocity.add(swingForceVector);
                            
                            // Use gas
                            gas -= SWING_GAS_COST;
                        }
                        
                        // Cord length constraint - prevent cord from stretching beyond max length
                        if (hooks[side].length > hooks[side].maxLength) {
                            // Pull player back to max cord length
                            const dirToHook = new THREE.Vector3().subVectors(hookPos, playerPos).normalize();
                            const correction = new THREE.Vector3().copy(dirToHook).multiplyScalar(hooks[side].length - hooks[side].maxLength);
                            yawObject.position.add(correction);
                            
                            // Remove velocity component that extends the cord
                            const velocityTowardHook = velocity.dot(dirToHook);
                            if (velocityTowardHook < 0) { // Moving away from hook
                                velocity.addScaledVector(dirToHook, -velocityTowardHook);
                            }
                        }
                    
                        // Update hook line
                        if (hooks[side].line) {
                            const positions = hooks[side].line.geometry.attributes.position.array;
                            positions[0] = playerPos.x;
                            positions[1] = playerPos.y;
                            positions[2] = playerPos.z;
                            positions[3] = hookPos.x;
                            positions[4] = hookPos.y;
                            positions[5] = hookPos.z;
                            hooks[side].line.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                });
            } else {
                // Normal movement when not swinging - but preserve momentum in air!
                if (isOnGround) {
                    // Only apply heavy damping when on ground
                    velocity.x -= velocity.x * GROUND_FRICTION * delta;
                    velocity.z -= velocity.z * GROUND_FRICTION * delta;
                } else {
                    // Much lighter air resistance when flying - preserve momentum!
                    velocity.x -= velocity.x * AIR_RESISTANCE * delta;
                    velocity.z -= velocity.z * AIR_RESISTANCE * delta;
                }
            
                // Calculate movement direction in world space
                direction.set(0, 0, 0);
                
                if (moveForward) direction.z -= 1;
                if (moveBackward) direction.z += 1;
                if (moveLeft) direction.x -= 1;
                if (moveRight) direction.x += 1;
                
                // Normalize direction
                if (direction.length() > 0) {
                    direction.normalize();
                    
                    // Transform direction to world space based on yaw rotation
                    const worldDirection = new THREE.Vector3();
                    worldDirection.copy(direction);
                    worldDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
                    
                    // Apply movement - but reduce control when in air to make it more realistic
                    const movementMultiplier = isOnGround ? 1.0 : AIR_CONTROL; // Less air control
                    velocity.x += worldDirection.x * WALK_SPEED * delta * movementMultiplier;
                    velocity.z += worldDirection.z * WALK_SPEED * delta * movementMultiplier;
                }
            }
        
            // Calculate new position
            const newPosition = new THREE.Vector3(
                yawObject.position.x + velocity.x * delta,
                yawObject.position.y + velocity.y * delta,
                yawObject.position.z + velocity.z * delta
            );
            
            // Check for collisions
            const collision = checkCollision(newPosition);
            
            if (collision.collision) {
                if (collision.sideCollision) {
                    // Side collision - stop horizontal movement and adjust position
                    velocity.x = 0;
                    velocity.z = 0;
                    if (collision.correctedX !== undefined) yawObject.position.x = collision.correctedX;
                    if (collision.correctedZ !== undefined) yawObject.position.z = collision.correctedZ;
                    yawObject.position.y = newPosition.y; // Allow vertical movement
                    currentSurface = collision.surface;
                    isOnGround = false;
                } else {
                    // Rooftop or ground collision
                    velocity.y = 0;
                    yawObject.position.x = newPosition.x;
                    yawObject.position.z = newPosition.z;
                    yawObject.position.y = collision.correctedY;
                    currentSurface = collision.surface;
                    isOnGround = true;
                }
            } else {
                // No collision - apply movement normally
                yawObject.position.copy(newPosition);
                currentSurface = 'Air';
                isOnGround = false;
            }
        
            // Regenerate gas
            if (gas < 100) {
                gas = Math.min(100, gas + GAS_REGEN_RATE);
            }
        }
    
        function updateUI() {
            const pos = yawObject.position;
            document.getElementById('position').textContent = 
                `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
    
            const speed = Math.sqrt(velocity.x**2 + velocity.y**2 + velocity.z**2);
            document.getElementById('speed').textContent = speed.toFixed(1);
            
            const height = Math.max(0, pos.y - PLAYER_HEIGHT);
            document.getElementById('height').textContent = height.toFixed(1);
            
            document.getElementById('surface').textContent = currentSurface;
    
            updateHookUI();
        }
    
        let frameCount = 0;
        let lastFpsUpdate = 0;
    
        function animate() {
            requestAnimationFrame(animate);
    
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
    
            updateMovement(delta);
            updateUI();
    
            // FPS counter
            frameCount++;
            if (time - lastFpsUpdate >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsUpdate = time;
            }
    

			// Add this line to slowly rotate the moon
			if (moon) moon.rotation.y += 0.001;

            renderer.render(scene, camera);
            prevTime = time;
        }
    
        // Start the game
        init();
    </script>
</body>
</html>
